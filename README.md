
# Project3-Interactive_OS_and_Process_Management

## Test Sets

`waitpid ready_to_exit wait_locks`：启动进程，拿锁，等待，退出测试

`barrier`：屏障测试（三个进程都到达屏障才可有下一步动作）

`sema`：信号量测试（三个生产者，三个消费者，必须等待到进行消费，消费者才可以进入临界区消费）

`mbox`:  信箱测试（一个生产者传输字符，可以启动多个进程接受字符，本质在于写管程）

`multicore`：双核性能测试，希望能达到接近2的加速比

`affinity`:  绑核测试，希望能看到明显的速度差异

## Debug

P3同步操作的debug部分并不算很复杂，其中较为复杂的在于启动进程以及双核的相关debug

1. 注意到现在有大于16个进程，因此tasks和pcb数组需要扩容，可以扩容到32个
2. exec进行命令行参数传参时，容易出错，需要注意相关sp的设置
3. 关于shell进程，由于是单纯的软件，因此bug都非常容易定位，不过多赘述
4. 在同步相关操作的设计中，我所采用的设计都是mesa风格，所有的同步量都用自旋锁实现，包括互斥锁，屏障，信号量，信箱等。由于最开始我尝试过小锁的设计，因此可以在我代码中很明显地看到小锁的痕迹。在代码中，我采用mesa风格，即对所有的临界区，我首先用配套的自旋锁将其保护起来；中途如果出现需要等待的情况，则调用do_block函数将其加入到对应的队列中，并将这把小锁释放掉。这种风格可以让代码更加程式化和简洁，希望对做小锁的学弟学妹能有所帮助

#### 关于双核

在双核的设计过程中（这里只说大内核锁），有三个需要注意的点：

1. 对整个内核的上锁，我采取在保存上下文处上锁的方案，在entry.S中可以看到
2. 关于双核的唤醒，我采用给所有的核发中断的方式，但注意主核要将自己的中断信号清除，否则会报错（也可用掩码进行设置）
3. current_running，我采用让其成为一个指针的方案，每次进程修改时让其指针指向的地方进行修改。注意current_running是不能保存在栈中的，因为它代表当前运行这段代码的核，可能同一段代码在不同阶段由两个核来分别运行。因此current_running必须要即时获得

以上所述均是大内核锁的设计，双核的debug是较为痛苦的，必要时得用printl打印很多内容才能发现问题。gdb也时常会出现从0核运行处跳到1核运行处，还需仔细进行甄别。关于细粒度锁的设计，就爱莫能助了。


# Project4-Virtual_Memory_Management

## Test Sets

`fly`：小飞机测试，在命令行按下 `exec fly`

`rw`：读写，测试缺页处理，将测试地址以命令行参数输入，如 `exec rw 0x10800000 0xa0100000`，在这两个地址上写入随机数，然后再读出，即可测试这两个地址的缺页处理，当出现 Succcess! 字样时，测试成功

`swap`：页替换测试，在命令行输入 `exec swap`，从0x10000000开始依次写入768个页，并在后面一致读出。因为768个页已经超过系统所允许的最大物理空间，因此一定会出现换页的情况

`lock`:  拿锁测试，几个程序依次拿锁

`mailbox`：主要检验线程的创建，有三个进程相互发消息，每个进程会创建两个线程一个负责收一个负责发每发128次为一个循环

`fork`:  父线程创建子线程，要求实现写时复制

`consensus`:  共享页测试。启动一个consensus进程，会创建很多个consensus进程。这些进程会对物理也进行共享。每次循环都会有一个进程完成自己对共享页的操作，具体情况详见任务书

## Debug

虚存的debug可以说是所有的project中最难的一个，原因在于相较于前面的project代码量增多，同时涉及到虚实地址的转换，很可能会出现访问地址出错而卡死的情况。在这里我结合了我们这一届oslab同学的经历，总结了一些常见的bug以及debug的思路，希望能够对学弟学妹们有所帮助。

#### 1.进入内核

进入内核的代码已经在boot.c中全部写好，不需要再进行任何操作。需要对makefile中的编译地址进行修改(改为虚地址)，将createimage.c中的filesz改为memsiz，同时检查head.S，crt0.S中等栈的设置，一定要注意根据当前运行在虚地址还是实地址上来进行栈的设置，其他无需进行修改

如果做了压缩，注意到压缩也是在实地址上运行的，因此可能需要将压缩中调用的函数重新复制一份直接放到decompress.c中。因为现在压缩和内核一个运行在实地址上一个运行在虚地址上(编译在不同的文件中)，且压缩时页表映射还没有建立好，因此非位置无关代码是不能跳转的

#### 2.关于双核

由于我没有实现双核的细粒度锁，因此在这里无法给予细粒度锁的指导。对于大内核锁，实际上并不需要进行什么修改，只需要注意如下两点即可：

* shell的初始化尽可能往后放，要保证在init_shell时内核的pcb表，物理页框表都已经可以进行分配，否则可能会出init时卡死，甚至可能当时不会出问题，而在成功启动之后后续的某个地方卡死(曾经有同学在P5进行IO的内存映射时，由于没有放在pcb表，物理页框表初始化之后，导致IO映射出错，最后运行shell触发IO中断时，地址访问出错而卡死)
* 临时映射是否删除？这里我给出的建议是在内核页表中不进行删除，但是在复制内核页表给每个进程选择性地进行拷贝，即不拷贝临时映射这一段。因为现在是双核，直接贸然将临时映射删除可能导致第二个核进入时触发缺页，从而只能进行动态的物理页表分配(原则上内核代码的映射应该咋boot.c中全部完成，不会通过动态的物理页分配来映射)

#### 3.内核卡死

从P4开始往后走几乎99%的内核卡死问题都是因为地址访问出错（针对大内核锁而言，P3中可能是因为发生死锁，但是P3将大内核锁的框架建立好并且P4在解决掉上面两个问题后，后面关于死锁的问题并不容易出现了），因此一定要着重检查多级页表映射和sum位是否拉高

这里着重提醒一点，sum位不光是用户进程的sum位需要拉高，pid0，pid1两个一直空转的进程sum位也要拉高。原因在于如果有一个A进程（如mailbox）因为接收或发送的问题阻塞，那么在被唤醒时无疑是在内核态，这个时候还没有通过trap返回恢复trapframe进而恢复A进程的sstatus寄存器，因此sstatus位仍然是当前B进程的sstatus。而mailbox被唤醒之后在内核态就要立刻访问一个用户态的地址(mailbox函数的参数)，这时候如果sum位没有被拉高，就会出现访问地址不合规从而卡死的情况

解决上述问题有两个办法，一个是上面我提到的全部进程sum位拉高(enable_interrupt中操作，我当时的选择)，一个是在switchto中也实行sstatus的切换，被唤醒之后sstatus就是A进程的了。这个bug当时花费了我2天的时间，可能是一个很微小，别人都不会犯的错误，但对我而言是具有深刻意义的

访问地址出错的原因一般就两个：页表映射出错，权限等级出错。卡死bug很难解决的原因是因为bug很难被定位到。因此一定要善用printl工具，同时尽可能使用助教提供的vscode debug工具链（图形化界面相比命令行gdb方便太多），可以安装Hex Editor插件，方便直接查看内存进行页表的检查。

#### 4.常见bug

以下罗列出虚存常见的一些bug，罗列出的bug为我自己以及周围同学一些花费时间较长的bug

1. 用户栈的分配。用户栈在分配完毕后，给用户的并不是低地址，而是这一页的高地址
2. pin与unpin。内核页表和用户占均为动态分配，那么swap时允不允许被换出？这里的建议是为了实现简单，可以将这些pin住，仅仅在用户进程对一些地址进行读写时unpin而可以换出
3. satp。注意satp寄存器中一定是实地址，因为这是为了方便硬件walk，在TLBmiss时进行TLB重填
4. 页表的回收与页的回收。
   1）不要在exit中进行进程的页表回收，因为接下来的schedular还要用到被回收进程的页表
   2）线程创建时会共享页表，进程创建时不会共享页表，只是指向同一张页表。因此这里建议释放页表与释放物理页框松耦合，可能会出现一个释放而另一个不需要释放的情况。可以考虑对于每一个物理页框做一个结构体，结构体中记录这个物理页框被多少个线程或进程使用
   3）仿照linux，则子进程的资源应该有父进程回收；但这里可以进行简化，所有用户进程的资源均由shell进程在shedular函数中进行回收
5. 物理页分配出去时需要进行清零，其它时刻不需要清零
6. 这里可能会涉及到上板不过的问题，原因是因为没有刷icache，导致取指令出错(qemu上无法模拟icache)。因此建议在shedular函数的末尾补上一句local_flush_icache()
7. 关于mailbox，听说运行很长时间后就会卡住。并且mailbox在创建线程之后，建议在测试程序的每个线程函数的末尾加上一句sys_exit()来进行线程的退出

# Project5 - DeviceDriver

## Test Sets

`send`：发消息测试，在命令行输入 `exec send `，测试集中设置的是发送4个包，可以用wireshark查看

`recv`：接收消息测试，在命令行输入 `exec recv`，接收时启动pktRxTx程序，可以选择接收60个包或接收60秒

`recv_stream`: C_core测试，启动ack和rsd机制

## Debug

1. 注意对于IO外设一定是实地址，用虚地址会报错
2. 注意main函数中的框架，e1000和plic的init
3. 双核上板中断会路由给两个核，第二个核进入内核时注意直接退出，此时对应中断位已经被清零
4. pktRxTx小程序有bug，注意进行重传时一是不要太过频繁，8秒即可；2是这时候不要采用中断唤醒机制，采用定时唤醒机制

## 2024.10.14更新
暑假期间已经对小程序的bug进行修复，现在除可能会在运行的过程中无故打印出RSD error，实际上已经不会对网络传输造成影响；对于当年C-core暑假已经通过压力测试(700KB乱序50%丢包10%320KB窗口，最快13s内可以完成)

(注意今年的Ccore有改变)

# Project6 - FileSystem

## Shell Commands

`mkfs`：创建文件系统，正常情况下由于文件系统已经初始化好，所以使用该命令会报错

`statfs`：显示文件系统信息，包括魔术字，FS起始块号，inode map起始块号，block map起始块号，inode使用情况及起始块号，data block使用情况及起始块号，inode大小，dentry大小

`cd`：切换目录，比如 `cd ..`切换至上级目录

`mkdir`：创建目录，如果已存在会报错

`rmdir`：删除目录，如果不存在会报错

`ls`：打印目录项，可以加上 `-l`参数，打印inode号、文件大小、链接数、修改时间

`touch`：创建空文件

`cat`：显示文件内容

`ln`：创建硬链接，支持相对路径和绝对路径

`rmfile`：删除文件/链接，目前仅支持一个direct block，超出会报错

## Test Sets

`rwfile`: 先touch 1.txt,2.txt,然后运行改程序，会打印1.txt中的内容

`rwbigfile`: 以256KB为步长，循环32次每次写入一个数并立刻读出，如果读出的书与前面括号中的数相匹配则正确

`bigfile_persist`: 检测大文件的持久化，从硬盘中读出并与对应的数进行比较，如果出错会报"read error",同时可以检测bcache的性能

## Debug

P6的debug部分没有特别难，基本只要投入一定时间就肯定会有回报，希望能够注意的有以下几点：

* 关于bcache的问题。由于我们采取的是写穿策略，因此注意bcache一定要随时与硬盘同步。注意每次分配出一块bcache后，可能会被后面从硬盘上读出的块给冲掉，这点一定要注意(尽量保证强序)
* 在debug的过程中，可以用checkblock的策略来检测持久化是否做得很好

P6文件系统中有几个常见的喜欢犯的错误，比如传递一个字符指针，但是直接对这个指针指向的地址进行修改，从而导致一些不该修改的地方出现意想不到地被修改的情况,但是这种错误通过一步步调试是很容易发现的，因此不过多赘述
