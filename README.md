
# Project4-Virtual_Memory_Management

## Test Sets

`fly`：小飞机测试，在命令行按下 `exec fly`

`rw`：读写，测试缺页处理，将测试地址以命令行参数输入，如 `exec rw 0x10800000 0xa0100000`，在这两个地址上写入随机数，然后再读出，即可测试这两个地址的缺页处理，当出现 Succcess! 字样时，测试成功

`swap`：页替换测试，在命令行输入 `exec swap`，从0x10000000开始依次写入768个页，并在后面一致读出。因为768个页已经超过系统所允许的最大物理空间，因此一定会出现换页的情况

`lock`:  拿锁测试，几个程序依次拿锁

`mailbox`：主要检验线程的创建，有三个进程相互发消息，每个进程会创建两个线程一个负责收一个负责发每发128次为一个循环

`fork`:  父线程创建子线程，要求实现写时复制

`consensus`:  共享页测试。启动一个consensus进程，会创建很多个consensus进程。这些进程会对物理也进行共享。每次循环都会有一个进程完成自己对共享页的操作，具体情况详见任务书

## Debug

虚存的debug可以说是所有的project中最难的一个，原因在于相较于前面的project代码量增多，同时涉及到虚实地址的转换，很可能会出现访问地址出错而卡死的情况。在这里我结合了我们这一届oslab同学的经历，总结了一些常见的bug以及debug的思路，希望能够对学弟学妹们有所帮助。

#### 1.进入内核

进入内核的代码已经在boot.c中全部写好，不需要再进行任何操作。需要对makefile中的编译地址进行修改(改为虚地址)，将createimage.c中的filesz改为memsiz，同时检查head.S，crt0.S中等栈的设置，一定要注意要根据当前运行在虚地址还是实地址上来进行栈的设置，其他的无需进行修改

如果做了压缩，注意到压缩也是在实地址上运行的，因此可能需要将压缩中调用的函数重新复制一份直接放到decompress.c中，因为现在压缩和内核一个运行在实地址上一个运行在虚地址上，并且压缩时页表映射还没有建立好，因此非位置无关代码是不能跳转的

#### 2.关于双核

由于我没有实现双核的细粒度锁，因此在这里无法给予细粒度锁的指导。对于大内核锁，实际上并不需要进行什么修改，只需要注意如下两点即可：

* shell的初始化尽可能往后放，要保证在init_shell时内核的pcb表，物理页框表都已经可以进行分配，否则可能会出init时卡死，甚至可能当时不会出问题，而在成功启动之后后续的某个地方卡死(曾经有同学在P5仅从IO的内存映射时，由于没有放在init_shell前面，导致shell的内核页表没有进行IO映射，最后每当运行shell进程触发IO中断时，地址访问出错而卡死)
* 临时映射是否删除？这里我给出的建议是在内核页表中不进行删除，但是在复制内核页表给每个进程是选择性的进行拷贝，即不拷贝临时映射这一段。这是因为现在是双核，直接贸然的将临时映射删除掉可能导致第二个核进入时触发缺页，从而只能进行动态的物理页表分配

#### 3.内核卡死

从P4开始往后走几乎99%的内核卡死问题都是因为地址访问出错（针对大内核锁而言，P3中可能是因为发生死锁，但是P3将大内核锁的框架建立好之后，P4在解决掉上面两个问题后，后面关于死锁的问题并不容易出现了），因此一定要着重检查多级页表映射和sum位是否拉高

这里着重提醒一点，sum位不光是用户进程的sum位需要拉高，pid0，pid1两个一直空转的进程sum位也要拉高。原因在于如果有一个A进程（如mailbox）因为接收或发送的问题阻塞，那么在被唤醒时无疑是在内核态，这个时候还没有通过trap返回恢复trapframe而恢复A进程的sstatus寄存器，因此sstatus位仍然是当前B进程的sstatus。而mailbox被唤醒之后在内核态就要立刻访问一个用户态的地址(mailbox函数的参数)，这时候如果sum位没有被拉高，就会出现访问地址不合规从而卡死的情况

解决上述问题有两个办法，一个是上面我提到的全部sum位拉高，一个是在switchto中也实行sstatus的切换，被唤醒之后sstatus就是A进程的了。这个bug当时花费了我2天的时间，可能是一个很微小，别人都不会犯的错误，但对我而言是具有深刻意义的

访问地址出错的原因一般就两个：页表映射出错，权限等级出错。卡死bug很难解决的原因是因为bug很难被定位到。因此一定要善用printl工具，同时尽可能使用助教提供的vscode debug工具链（图形化界面相比命令行gdb方便太多），可以安装Hex Editor插件，方便直接查看内存进行页表的检查。

#### 4.常见bug

以下罗列出虚存常见的一些bug，罗列出的bug为我自己以及周围同学一些花费时间较长的bug

1. 用户栈的分配。用户栈在分配完毕后，给用户的并不是低地址，而是这一页的高地址
2. pin与unpin。内核页表和用户占均为动态分配，那么swap时允不允许被换出？这里的建议是为了实现简单，可以将这些pin住，仅仅在用户进程对一些地址进行读写时unpin而可以换出
3. satp。注意satp寄存器中一定是实地址，因为这是为了方便硬件walk，在TLBmiss时进行TLB重填
4. 页表的回收与页的回收。
   1）不要在exit中进行进程的页表回收，因为接下来的schedular还要用到被回收进程的页表
   2）线程创建时会共享页表，进程创建时不会共享页表，只是指向同一张页表。因此这里建议释放页表与释放物理页框松耦合，可能会出现一个释放而另一个不需要释放的情况。可以考虑对于每一个物理页框做一个结构体，结构体中记录这个物理页框被多少个线程或进程使用
   3）仿照linux，则子进程的资源应该有父进程回收；但这里可以进行简化，所有用户进程的资源均由shell进程在shedular函数中进行回收
5. 物理页分配出去时需要进行清零，其它时刻不需要清零
6. 这里可能会涉及到上板不过的问题，原因是因为没有刷icache，导致取指令出错(qemu上无法模拟icache)。因此建议在shedular函数的末尾补上一句local_flush_icache()
7. 关于mailbox，听说运行很长时间后就会卡住。并且mailbox在创建线程之后，建议在测试程序的每个线程函数的末尾加上一句sys_exit()来进行线程的退出
